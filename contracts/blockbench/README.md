# blockBench
`analyticTC` is based on the Analytic benchmark in
[BlockBench](https://github.com/ooibc88/blockbench).

### analyticTC

For your reference, the original description of the Analytic benchmark in the
SIGMOD paper is like the below:
> This workload considers the performance of blockchain system in answering
> analytical queries about the historical data. Similar to an OLAP benchmark,
> this workload evaluates how the system implements scan-like and aggregate
> queries, which are determined by its data model.

`analyticTC` implements three analytic operations using Klaytn's JSON RPC API.
The table below describes the three operations.

| Function | Description |
| -------- | ----------- |
| `QueryTotalTxVal` | Calculate the sum of transaction's values in the latest 30 blocks. It internally calls `klay_getBlockByNumber` through Klaytn's Client interface. |
| `QueryLargestTxVal` | Find the largest transaction value in the latest 30 blocks. It internally calls `klay_getBlockByNumber` through Klaytn's Client interface.|
| `QueryLargestAccBal` | Find the largest balance of a randomly chosen account in the latest 30 blocks. It internally calls `klay_getBalance` through Klaytn's Client interface.|
| `Run` | Randomly invoke one test function among `QueryTotalTxVal`, `QueryLargestTxVal`, and `QueryLargestAccBal`. |


### Source Files

This directory includes one source file:

- `analyticTC.go`: initialization and test functions implementation
  - Took the overall idea from [BlockBench's Analytic benchmark](https://github.com/ooibc88/blockbench/tree/master/src/micro/analytic)


## References

- [BlockBench github repository](https://github.com/ooibc88/blockbench)
- [BLOCKBENCH: A Framework for Analyzing Private Blockchains](https://dl.acm.org/citation.cfm?id=3064033), published in SIGMOD '17


# doNothingTC

## Test Case Description

`doNothingTC` is based on the DoNothing benchmark in
[BlockBench](https://github.com/ooibc88/blockbench).

For your reference, the original description of DoNothing benchmark in the SIGMOD
paper is like the below:
> This contract accepts transaction as input and simply returns. In other
> words, it involves minimal number of operations at the execution layer and
> data model layer, thus the overall performance will be mainly determined by
> the consensus layer. Previous works on performance of blockchain consensus
> protocol use time to consensus to measure its performance. In BLOCKBENCH,
> this metric is directly reflected in the transaction latency.

`doNothingTC` implements a Go test function that calls the `nothing` function,
whose body is empty (i.e., does nothing), in the `Nothing` contract implemented
in `DoNothing.sol`.

| Function | Description |
| -------- | ----------- |
| `Run` | Call the `nothing` function, which does nothing, in the `DoNothing` contract |


## Source Files

This directory has the following source files.

- `DoNothing.sol`: `DoNothing` contract file written in solidity
  - Origin: https://github.com/ooibc88/blockbench/blob/master/benchmark/contracts/ethereum/donothing.sol
  - Updated the solidity version in the pragma statement to v0.4.24
  - Modified function signatures to suppress solc warnings
- `DoNothing.go`: Go binding code generated by `abigen` using `go generate`
- `doNothingTC.go`: initialization and test function implementation
  - Implemented test logic included in
    [https://github.com/ooibc88/blockbench/tree/master/src/macro/kvstore](https://github.com/ooibc88/blockbench/tree/master/src/macro/kvstore).
    Note that BlockBench implemented test routines in the driver of the YCSB
    benchmark.

## References

- [BlockBench github repository](https://github.com/ooibc88/blockbench)
- [BLOCKBENCH: A Framework for Analyzing Private Blockchains](https://dl.acm.org/citation.cfm?id=3064033), published in SIGMOD '17


# ioHeavyTC

## Test Case Description

`ioHeavyTC` is based on the IOHeavy benchmark in
[BlockBench](https://github.com/ooibc88/blockbench).

For your reference, the original description of IOHeavy benchmark in the SIGMOD
paper is like the below:
> Current blockchain systems rely on key-value storage to persist blockchain
> transactions and states. Each storage system may perform differently under
> different workloads. This workload is designed to evaluate the IO performance
> by invoking a contract that performs a large number of random writes and
> random reads to the contractâ€™s states. The I/O bandwidth can be estimated via
> the observed transaction latency.

Similarly to BlockBench's IOHeavy benchmark, `ioHeavyTC` evaluates the
performance of writing and reading Klaytn's states, especially state variables
declared in a smart contract.  The `IOHeavy` smart contract in `IOHeavy.sol` is
used for testing, and its functions are tested through the following interface
implemented in `ioHeavyTC.go`.

| Function | Description |
| -------- | ----------- |
| `Write` | Call the `write` function, which performs multiple write operations against storage variables (actually a map), in the `IOHeavy` contract with a randomly chosen but a range-limited integer key, the number of keys, and a signature (or identifier) recorded in the event log |
| `Scan` | Call the `scan` function, which reads multiple storage variables (actually a map), in the `IOHeavy` contract with a range-limited integer key, the number of keys, and a signature (or identifier) recorded in the event log |
| `Run` | Randomly invoke one test function between `Write` and `Scan` |


## Source Files

This directory has the following source files.

- `IOHeavy.sol`: `IOHeavy` contract file written in solidity
  - Origin: https://github.com/ooibc88/blockbench/blob/master/benchmark/contracts/ethereum/ioheavy.sol
  - Updated the solidity version in the pragma statement to v0.4.24
  - Modified function signatures to suppress solc warnings
- `IOHeavy.go`: Go binding code generated by `abigen` using `go generate`
- `ioHeavyTC.go`: initialization and test functions (i.e., `Write`, `Scan`, and `Run`) implementation
  - Implemented test logics in [https://github.com/ooibc88/blockbench/tree/master/src/micro/ioheavy/ethereum](https://github.com/ooibc88/blockbench/tree/master/src/micro/ioheavy/ethereum)


## References

- [BlockBench github repository](https://github.com/ooibc88/blockbench)
- [BLOCKBENCH: A Framework for Analyzing Private Blockchains](https://dl.acm.org/citation.cfm?id=3064033), published in SIGMOD '17

# smallBankTC

## Test Case Description

`smallBankTC` is based on the SmallBank benchmark in
[BlockBench](https://github.com/ooibc88/blockbench).

For your reference, the original description of SmallBank benchmark in the
SIGMOD paper is like the below:
> Unlike YCSB which does not consider transactions, Smallbank is a popular
> benchmark for OLTP workload. It consists of three tables and four basic
> procedures simulating basic operations on bank accounts. Smallbank is
> implemented as a smart contract which simply transfers money from one account
> to another.

`smallBankTC` tests basic bank operations using the `SmallBank` smart contract.
The test Go functions in `smallBankTC.go` and their corresponding function in
the `SmallBank` smart contract are described in the table below.

| Function | Description |
| -------- | ----------- |
| `Almagate` | Call the `almagate` function in the `SmallBank` contract, which moves the entire balance in one's checking account to the other's saving account |
| `GetBalance` | Call the `getBalance` function in the `SmallBank` contract, which returns the balance sum of one's checking and saving accounts |
| `UpdateBalance` | Call the `updateBalance` function in the `SmallBank` contract, which adds a given value to one's checking account |
| `UpdateSaving` | Call the `updateSaving` function in the `SmallBank` contract, which adds a given value to one's saving account |
| `SendPayment` | Call the `sendPayment` function in the `SmallBank` contract, which pays (or moves) a requested value from one's checking account to the other's |
| `WriteCheck` | Call the `writeCheck` function in the `SmallBank` contract, which tries to mimic the action of issuing a check (however, the implementation logic looks weird) |
| `Run` | Randomly invoke one test function among `Almagate`, `GetBalance`, `UpdateBalance`, `UpdateSaving`, `SendPayment`, and `WriteCheck` |


## How to Set the Maximum Number of Users

The environment variable `SMALLBANK_MAX_NUM_USERS` can be used to change the
maximum number of users, whose default value is 100000.  For example,
```shell
$ SMALLBANK_MAX_NUM_USERS=200000 ./klayslave ...
```

Note that the number of users can affect the performance of this test case
because the smart contract's state could be increased depending on the number
of different users.


## Source Files

This directory has the following source files.

- `SmallBank.sol`: `SmallBank` contract file written in solidity
  - Origin: https://github.com/ooibc88/blockbench/blob/master/benchmark/contracts/ethereum/smallbank.sol
  - Updated the solidity version in the pragma statement to v0.4.24
  - Modified function signatures to suppress solc warnings
- `SmallBank.go`: Go binding code generated by `abigen` using `go generate`
- `smallBankTC.go`: initialization and test functions implementation
  - Took the overall idea from [BlockBench's SmallBank benchmark code](https://github.com/ooibc88/blockbench/tree/master/src/macro/smallbank)

## References

- [BlockBench github repository](https://github.com/ooibc88/blockbench)
- [BLOCKBENCH: A Framework for Analyzing Private Blockchains](https://dl.acm.org/citation.cfm?id=3064033), published in SIGMOD '17

# ycsbTC

## Test Case Description

`ycsbTC` is based on the YCSB (KVStore) benchmark in
[BlockBench](https://github.com/ooibc88/blockbench) and is actually a
simplified version of the original YCSB benchmark.

For your reference, the original description of YCSB in the SIGMOD paper is
like the below:
> YCSB is a simple smart contract which functions as a key-value storage.  It
> preloads each store with a number of records, and supports requests with
> different ratios of read and write operations. YCSB is widely used for
> evaluating NoSQL databases.

`ycsbTC` tests a key-value storage, where both key and value are string, by
calling `set` and `get` functions defined in the `KVstore` smart contract
(`kvstore.sol`).  It provides the following functions for testing:

| Function | Description |
| -------- | ----------- |
| `Set` | Call the `set` function in the `KVstore` contract with a randomly chosen but a range-limited key and a random value |
| `Get` | Call the `get` function in the `KVstore` contract with a randomly chosen key, which has the same range as does the key used for the `set` function |
| `Run` | Randomly invoke one test function between `Set` and `Get` |


## How to Set the Maximum Number of Keys

The environment variable `YCSB_MAX_NUM_KEYS` can be used to change the maximum
number of keys, whose default value is 100000.  For example,
```shell
$ YCSB_MAX_NUM_KEYS=200000 ./klayslave ...
```

Note that the number of keys can affect the performance of this test case
because the smart contract's state could be increased depending on the number
of different keys.


## Source Files

This directory has the following source files.

- `kvstore.sol`: `KVstore` contract file written in solidity
   - Origin: https://github.com/ooibc88/blockbench/blob/master/benchmark/contracts/ethereum/kvstore.sol
   - Updated the solidity version in the pragma statement to v0.4.24
   - Modified function signatures to suppress solc warnings
- `kvstore.go`: Go binding code generated by `abigen` using `go generate`
- `ycsbTC.go`: initialization and test functions implementation
   - Took the overall idea from [the original YCSB benchmark in BlockBench](https://github.com/ooibc88/blockbench/tree/master/src/macro/kvstore)


## References

- [BlockBench github repository](https://github.com/ooibc88/blockbench)
- [BLOCKBENCH: A Framework for Analyzing Private Blockchains](https://dl.acm.org/citation.cfm?id=3064033), published in SIGMOD '17
